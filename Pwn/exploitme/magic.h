#ifndef _WIN32
typedef unsigned int DWORD;
#endif
void GCfree(void *p);

struct GCPool
{
	void* gc_p[0x100];
	DWORD gc_cnt;
};

/*
struct Top1
{
char *historyHighestScore;
Game *game;
};
Top1 top1;
*/

struct ByteArray{
	int len;
	char *buf;
};

typedef ByteArray *(*GETBA)(void *game);

struct Game
{
	DWORD id;
	//	int strlen;
	//	char *buf;
	DWORD score;
	ByteArray name;
	GETBA getBA;
	Game *next;
};

GCPool g_GC_Pool;
Game* top3[3] = { 0 };
void *customHeap = NULL;

ByteArray * getBA(void *game)
{
	return &(((Game *)game)->name);
}

void initCustomHeap()
{
	for (int i = 0; i < 0x10000 / 4; i += 0x100 / 4)
	{
		*((DWORD *)customHeap + i) = 1;
	}
	*((DWORD *)customHeap + (0x10000 - 0x100) / 4) = 0xdeadbeef;
	return;
}

void* allocFromCustomHeap(DWORD size)
{
	if (customHeap == NULL || size > 0xfc) return NULL;
	for (int i = 0; i < 0x10000 / 4; i += 0x100 / 4)
	{
		if (*((DWORD *)customHeap + i) == 0xdeadbeef)
		{
			printf("can't find valid block in custom heap.");
			return NULL;
		}
		if (*((DWORD *)customHeap + i) == 0x1) //flag 01 is free
		{
			*((DWORD *)customHeap + i) = 0x10; //flag 0x10 is busy
			return (void *)((DWORD *)customHeap + i + 1);
		}
	}
	return NULL;
}

void freeFromCustomHeap(void *p)
{
	if (customHeap == NULL || p == NULL)
		return;
	if ((DWORD)p >= (DWORD)customHeap + 0x10000 || (DWORD)p < (DWORD)customHeap)
		return;
	*((DWORD *)p - 1) = 1; //flag 01 is free
	//memset(p, 0, 0xfc);
}

class GameLists
{
public:
	/*	struct node
	{
	void *data;
	node *next;
	};
	typedef node* iterator;
	*/
	/*
	struct Game
	{
	DWORD id;
	//	int strlen;
	//	char *buf;
	ByteArray name;
	DWORD score;
	ShowName showname;
	Game *next;
	};
	*/
	typedef Game* iterator;
	int insert(int, char*, DWORD);
	iterator find(DWORD);
	void erase(DWORD);
	iterator end();
	void dump();
	//private:

	//	node*head;
	//	node*tail;
	Game*head;
	Game*tail;
	GameLists()
	{
		head = NULL;
		tail = NULL;
	}
};

GameLists::iterator GameLists::find(DWORD id)
{
	if (head == NULL)
		return NULL;
	Game*tmp = head;
	while (tmp)
	{
		if (tmp->id == id)
			return tmp;
		tmp = tmp->next;
	}
	return NULL;
}

int GameLists::insert(int len, char *buf, DWORD score)
{
	//	if (find(id))
	//		return;
	if (len > 0xfc)
	{
		printf("len is too long.\r\n");
		return -1;
	}
	char *mem = NULL;
	Game* newnode = NULL;

	mem = (char *)allocFromCustomHeap(len);
	newnode = (Game*)allocFromCustomHeap(sizeof(Game));


	int id = -1;
	if (newnode)
	{
		if (head == NULL)
		{
			id = 0;
			head = newnode;
			tail = newnode;
		}
		else
		{
			id = tail->id + 1;
			tail->next = newnode;
			tail = newnode;
		}
		newnode->id = id;
		memcpy(mem, buf, len);
		newnode->name.len = len;
		newnode->name.buf = mem;
		newnode->score = score;
		newnode->getBA = getBA;
		newnode->next = NULL;
		if (top3[0] == NULL)
		{
			top3[0] = newnode;
		}
		else if (top3[0]->score < score)
		{
			top3[0] = newnode;
		}
		return id;
	}
	return -1;

}

void GameLists::erase(DWORD id)
{
	Game*tmp, *td;
	if (head == NULL)
		return;
	if (head->id == id)
	{
		tmp = head;
		head = head->next;
		if (head == NULL)
			tail = NULL;
		//freeFromCustomHeap(tmp->name.buf);
		GCfree(tmp->name.buf);
		freeFromCustomHeap(tmp);
		return;
	}
	tmp = head;

	while (tmp->next)
	{
		if (tmp->next->id == id)
		{
			td = tmp->next;
			tmp->next = td->next;
			if (tail == td)
				tail = tmp;
			freeFromCustomHeap(td->name.buf);
			freeFromCustomHeap(td);
			break;
		}
		else
			tmp = tmp->next;
	}
}

GameLists::iterator GameLists::end()
{
	return NULL;
}

void GameLists::dump()
{
	Game*tmp = head;
	while (tmp)
	{
		printf("%s\n", tmp->name.buf);
		tmp = tmp->next;
	}
}

//////////////////////////////////


GameLists *m_GameLists = NULL;



/*
void showname(ByteArray *ba)
{
printf();
return;
}
*/

void GCfree(void *p)
{
	if (g_GC_Pool.gc_cnt <= 0x10)
	{
		g_GC_Pool.gc_p[g_GC_Pool.gc_cnt] = p;
		g_GC_Pool.gc_cnt++;
	}
	else
		freeFromCustomHeap(p);
}

//void WINAPI checkGCThreadProc(LPVOID lpParameter)
void checkGC()
{
	while (1)
	{
		if (g_GC_Pool.gc_cnt == 0x10)
		{
			for (DWORD i = 0; i <= g_GC_Pool.gc_cnt; i++)
			{
				if (g_GC_Pool.gc_p[i])
					freeFromCustomHeap(g_GC_Pool.gc_p[i]);
			}
			g_GC_Pool.gc_cnt = 0;
		}
		break;
		//Sleep(1);
	}
	return;
}

bool magic_init()
{
	memset(&g_GC_Pool, 0, sizeof(g_GC_Pool));

	//void *customHeap = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_READWRITE);
	customHeap = malloc(0x10000);
	if (customHeap == NULL)
	{
		printf("init custom heap failed.\r\n");
		return false;
	}

	initCustomHeap();

	m_GameLists = new GameLists();

	if (m_GameLists == NULL)
		return false;

	/*
	DWORD thread_id = 0;
	HANDLE hThread = CreateThread(NULL, 0, checkGCThreadProc, NULL, 0, &thread_id);
	if (hThread == NULL)
	{
		printf("Create checkGCThreadProc Thread failed.\r\n");
		return false;
	}
	*/
	return true;
}



////////////////

int adduser(int len, char *mem, DWORD score)
{
	int id = m_GameLists->insert(len, mem, score);

	return id;
}

void deluser(DWORD id)
{
	m_GameLists->erase(id);
	return;
}
/*
void showUser(DWORD id)
{
m_MemoryBlocks->find(id);
}
*/
/*
void editUser(DWORD id, char *newbuf, DWORD score)
{

return;
}
*/
ByteArray * showTop()
{
	if (top3[0] == NULL)
	{
		return NULL;
	}	
	else
	{
		Game * ga=top3[0];
		return ga->getBA(ga);
	}
}

bool editTop(int len, char *buf)
{
	if (top3[0] == NULL)
	{
		return false;
	}
	else
	{
		int size=0;
		if(top3[0]->name.len>0xf0)
		{
			size=top3[0]->name.len;
		}
		else
		{
			size=0xf0;
		}
		if (len<=size)
		{
			top3[0]->name.len = len;
			memcpy(top3[0]->name.buf, buf, len);
			return true;
		}
	}
	return true;
}

/*
void showRecords()
{
//id, name, score
m_MemoryBlocks->dump();
}
*/

/*
void DealWithCMD(int cmd)
{
switch (cmd)
{
case 0:
func0();
break;
case 1:
func1();
break;
case 2:
func2();
break;
case 3:
func3();
break;
case 4:
func4();
break;
}
}
*/
